<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>昊旻的博客  | 浅析MVC</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="浅析MVC" />
<meta property="og:description" content="MVC 是一种设计模式 简单介绍 MVC(Model-View-Controller) 首先是 Model 对象,用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。
const m = { 数据{ 将数据转为字符串本地储存，页面刷新无法清除数据 } 对数据进行增删改查 }  其次是 View 对象，内容一般与视图相关，描绘的是 model 的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。
const v = { 引入一个初始值为空的元素, 写入需要实现的html代码, 初始化, 将数据渲染为页面{ 判断初始值为空的元素的状态，根据不同的状态选择对应的方式进行渲染 } }  最后是 Controller，当完成前两部分之后剩下的内容我们都可以放到这里来，它处理用户的行为和数据 model 上的改变
const c = { 初始化， 寻找重要元素，调用对应的函数 }  EventBus 的常用 API 通常使用继承的方法来使用 EventBus
class EventBus { 将_EventBus写到原型链上面，即初始化 on(事件名，函数) { //监听函数 返回this._eventBus.on()的值 } trigger(事件名，数据) { //触发事件 返回this._eventBus.trigger()的值 } off(事件名，函数) { //取消监听 返回this._eventBus.off()的值 } }  表驱动编程 表驱动法(Table-Driven Approach),简单讲是指用查表的方法获取值，可以减少重复代码，使代码更加简洁。在程序中，数据的添加是非常简单，低成本和低风险的；而逻辑的添加是复杂，高成本和高风险的。表驱动方法可以让逻辑和数据分离，使用的关系表也可以更换。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zhouhaomin.top/posts/%E6%B5%85%E6%9E%90mvc/" />
<meta property="article:published_time" content="2019-12-20T19:19:55+08:00" />
<meta property="article:modified_time" content="2019-12-20T19:19:55+08:00" />
<meta itemprop="name" content="浅析MVC">
<meta itemprop="description" content="MVC 是一种设计模式 简单介绍 MVC(Model-View-Controller) 首先是 Model 对象,用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。
const m = { 数据{ 将数据转为字符串本地储存，页面刷新无法清除数据 } 对数据进行增删改查 }  其次是 View 对象，内容一般与视图相关，描绘的是 model 的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。
const v = { 引入一个初始值为空的元素, 写入需要实现的html代码, 初始化, 将数据渲染为页面{ 判断初始值为空的元素的状态，根据不同的状态选择对应的方式进行渲染 } }  最后是 Controller，当完成前两部分之后剩下的内容我们都可以放到这里来，它处理用户的行为和数据 model 上的改变
const c = { 初始化， 寻找重要元素，调用对应的函数 }  EventBus 的常用 API 通常使用继承的方法来使用 EventBus
class EventBus { 将_EventBus写到原型链上面，即初始化 on(事件名，函数) { //监听函数 返回this._eventBus.on()的值 } trigger(事件名，数据) { //触发事件 返回this._eventBus.trigger()的值 } off(事件名，函数) { //取消监听 返回this._eventBus.off()的值 } }  表驱动编程 表驱动法(Table-Driven Approach),简单讲是指用查表的方法获取值，可以减少重复代码，使代码更加简洁。在程序中，数据的添加是非常简单，低成本和低风险的；而逻辑的添加是复杂，高成本和高风险的。表驱动方法可以让逻辑和数据分离，使用的关系表也可以更换。">


<meta itemprop="datePublished" content="2019-12-20T19:19:55&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-20T19:19:55&#43;08:00" />
<meta itemprop="wordCount" content="80">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析MVC"/>
<meta name="twitter:description" content="MVC 是一种设计模式 简单介绍 MVC(Model-View-Controller) 首先是 Model 对象,用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。
const m = { 数据{ 将数据转为字符串本地储存，页面刷新无法清除数据 } 对数据进行增删改查 }  其次是 View 对象，内容一般与视图相关，描绘的是 model 的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。
const v = { 引入一个初始值为空的元素, 写入需要实现的html代码, 初始化, 将数据渲染为页面{ 判断初始值为空的元素的状态，根据不同的状态选择对应的方式进行渲染 } }  最后是 Controller，当完成前两部分之后剩下的内容我们都可以放到这里来，它处理用户的行为和数据 model 上的改变
const c = { 初始化， 寻找重要元素，调用对应的函数 }  EventBus 的常用 API 通常使用继承的方法来使用 EventBus
class EventBus { 将_EventBus写到原型链上面，即初始化 on(事件名，函数) { //监听函数 返回this._eventBus.on()的值 } trigger(事件名，数据) { //触发事件 返回this._eventBus.trigger()的值 } off(事件名，函数) { //取消监听 返回this._eventBus.off()的值 } }  表驱动编程 表驱动法(Table-Driven Approach),简单讲是指用查表的方法获取值，可以减少重复代码，使代码更加简洁。在程序中，数据的添加是非常简单，低成本和低风险的；而逻辑的添加是复杂，高成本和高风险的。表驱动方法可以让逻辑和数据分离，使用的关系表也可以更换。"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://zhouhaomin.top/" class="f3 fw2 hover-white no-underline white-90 dib">
      昊旻的博客
    </a>
    <div class="flex-l items-center">
      

      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">浅析MVC</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-12-20T19:19:55&#43;08:00">December 20, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="mvc-是一种设计模式">MVC 是一种设计模式</h2>

<h2 id="简单介绍-mvc-model-view-controller">简单介绍 MVC(Model-View-Controller)</h2>

<p>首先是 Model 对象,用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。</p>

<pre><code>const m = {
    数据{
        将数据转为字符串本地储存，页面刷新无法清除数据
    }
    对数据进行增删改查
}
</code></pre>

<p>其次是 View 对象，内容一般与视图相关，描绘的是 model 的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。</p>

<pre><code>const v = {
    引入一个初始值为空的元素,
    写入需要实现的html代码,
    初始化,
    将数据渲染为页面{
        判断初始值为空的元素的状态，根据不同的状态选择对应的方式进行渲染
    }
}
</code></pre>

<p>最后是 Controller，当完成前两部分之后剩下的内容我们都可以放到这里来，它处理用户的行为和数据 model 上的改变</p>

<pre><code>const c = {
    初始化，
    寻找重要元素，调用对应的函数
}
</code></pre>

<h2 id="eventbus-的常用-api">EventBus 的常用 API</h2>

<p>通常使用继承的方法来使用 EventBus</p>

<pre><code>class EventBus {
  将_EventBus写到原型链上面，即初始化

  on(事件名，函数) {
    //监听函数
    返回this._eventBus.on()的值
  }

  trigger(事件名，数据) {
    //触发事件
    返回this._eventBus.trigger()的值
  }

  off(事件名，函数) {
    //取消监听
    返回this._eventBus.off()的值
  }
}

</code></pre>

<h2 id="表驱动编程">表驱动编程</h2>

<p>表驱动法(Table-Driven Approach),简单讲是指用查表的方法获取值，可以减少重复代码，使代码更加简洁。在程序中，数据的添加是非常简单，低成本和低风险的；而逻辑的添加是复杂，高成本和高风险的。表驱动方法可以让逻辑和数据分离，使用的关系表也可以更换。</p>

<p>使用表驱动编程的意义总结：</p>

<ol>
<li>逻辑与数据分离</li>
<li>逻辑修改成本巨大，数据修改成本极小</li>
<li>数据来源灵活，数据改变灵活</li>
</ol>

<h2 id="模块化">模块化</h2>

<p>学习 MVC 是第一次接触模块化，毫无疑问模块化就是把原来整页整页的代码划分成一个个模块。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。改变某个子功能只需相应改变相应模块即可。</p>

<p>我想这样做的好处有很多，比如不同模块的代码负责不同的网页部分，当发现一部分网页出现问题时，可以精准的找到错误的地方；再比如当一个项目比较大的时候，需要多个人员参与开发，那么每个人负责自己的模块就可以大大提高团队的效率，缩短产品研发与制造周期；同理当后来的开发者想要对原有的代码进行改进时，模块化也可以极大提高工作的效率。</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://zhouhaomin.top/" >
    &copy;  昊旻的博客 2020 
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
